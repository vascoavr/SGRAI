<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <script src="js/three.js"></script>
        <script src="js/GLTFLoader.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/dat.gui.js"></script>
		<script src="js/utility.js"></script>
		<script src="models/factory_building/factory_building.js"></script>
        <script src="models/conveyor_belt/conveyor_belt.js"></script>
        <script type="module">
            import { machines } from './models/machines/machines.js';
            import { setMachineProperties } from './models/machines/machines.js';

            var gltfLoader = new THREE.GLTFLoader();
            
            let renderer, camera, scene, controls;
            let groupFactoryBuilding;
            
            var factoryBuilding;

            var factoryDisposition = [];
            var machinesOnScene = [];

            var selectedMachine;

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener("keydown", onDocumentKeyDown, false);
            
            init();
            animate();
            
            function init() {
                renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );
                camera.position.set( 0, 200, 400 );
            
                scene = new THREE.Scene();
                
                var light = new THREE.AmbientLight();//to light 3d models
                scene.add(light);
            
                //orbit controls
                controls = new THREE.OrbitControls( camera, renderer.domElement );             
                
                /*Widgets*/
                createGUI();
                
                /*Factory Building*/
                factoryBuilding = new FactoryBuilding();
                scene.add(factoryBuilding.draw());

                // loads the factory from the text file
                loadFactory();
            }

            function loadFactory() {
                let loader = new THREE.FileLoader();
                loader.load(
                    'factory2.txt', 
                    function (data) {
                        drawProductionLines(data.split('\n'));
                    },
                    function (xhr) {
		                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
	                },
	                function (err) {
		                console.error('An error happened');
                    }
                );
            }

            function drawProductionLines(productionLines) {
                for (let i = 0; i < productionLines.length; i++) {
                    let lineName = productionLines[i].substr(0, productionLines[i].indexOf(':'));
                    let machines = productionLines[i].trim().substr(productionLines[i].indexOf(':') + 1).split(',');

                    let cb = new ConveyorBelt();
                    let line = cb.scaleConveyorBelt(machines.length);
                    
                    line.position.set(-100, 11, 50 * i - 75);
                    scene.add(line);

                    // matrix with the disposition of all the machines
                    factoryDisposition[i] = new Array(machines.length);

                    for (let j = 0; j < machines.length; j++) {
                        drawMachine(machines[j].trim(), i, j);
                    }
                }
            }

            function drawMachine(machineType, lineNumber, machineNumber) {
                let found = machines.find(m => m.type === machineType);
                let machine;

                if (found) {
                    const path = found.model + '/scene.gltf';

                        gltfLoader.load(
                            path,
                            function (gltf) {
                                // checks if a machine from the same type exists
                                let machineSameTypeExists = machinesOnScene.find(m => m.machineType === machineType);

                                if (machineSameTypeExists) {
                                    machine = machineSameTypeExists.clone();
                                } else {
                                    machine = gltf.scene;
                                }

                                machine.machineType = machineType;
                                machine = setMachineProperties(machine, machineNumber, lineNumber);

                                scene.add(machine);
                                machinesOnScene.push(machine);

                                // store the machine in the matrix
                                factoryDisposition[lineNumber][machineNumber] = machine;
                            }
                        );
                } else {
                    factoryDisposition[lineNumber][machineNumber] = 0;
                }
            }
            
            function animate() {
                requestAnimationFrame( animate );              
                renderer.render( scene, camera );
            }
            
            /*Widget*/
            function createGUI() {
                var settings = {
                    'show roof': false
                };
                
                var gui = new dat.GUI();
                
                var folder1 = gui.addFolder("Visibility");
                folder1.add(settings, 'show roof').onChange(showRoof);
                folder1.open();
            }
            
            /*Show and hide roof/walls*/
            function showRoof(showRoof){
                if(showRoof) { //if walls and roof not showing
                    factoryBuilding.showRoof();
                } else {
                    factoryBuilding.hideRoof();
                }
            }
            
            /*Event Listeners*/
            function onWindowResize() {
                camera.aspect = window.innerWidth/ window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onDocumentMouseDown(event) {
                // mouse position
                let mouse = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1,
                                            -( event.clientY / window.innerHeight ) * 2 + 1,
                                            0.5);

                let raycaster =  new THREE.Raycaster();                                        
                raycaster.setFromCamera(mouse, camera);
                // create an array containing all machines in the scene with which the ray intersects
                let intersects = raycaster.intersectObjects(machinesOnScene, true);

                // if there is one (or more) intersections
                if (intersects.length > 0) {
                    selectedMachine = intersects[0].object;

                    // get the UUID
                    let flag = false;
                    while (!flag) {
                        if (selectedMachine.type === "Scene") {
                            flag = true;
                            selectedMachine = selectedMachine.uuid;
                        } else {
                            selectedMachine = selectedMachine.parent;
                        }
                    }

                    // temporary
                    intersects[0].object.scale.set(2, 2, 2);
                }
            }

            function onDocumentKeyDown(event) {
                let keyCode = event.which;
                
                // A or D key
                if (keyCode === 65 || keyCode === 68) {
                    if (selectedMachine) {
                        var position = findIndices(selectedMachine);
                    }

                    // D key
                    if (keyCode === 68) {
                        if ((position.j+1) < factoryDisposition[position.i].length) {
                            // stores the machine
                            let machine = factoryDisposition[position.i][position.j];

                            // position is free
                            if (!factoryDisposition[position.i][position.j+1]) {
                                // stores the machine's new position
                                factoryDisposition[position.i][position.j+1] = machine;
                                // clears the machine's previous position
                                factoryDisposition[position.i][position.j] = 0;

                                // moves the machine to the right
                                machine.translateZ(-48);
                            } 
                            // position already has another machine
                            else {
                                // stores the second machine
                                let machine2 = factoryDisposition[position.i][position.j+1];

                                // swaps the machines' positions
                                factoryDisposition[position.i][position.j] = machine2;
                                factoryDisposition[position.i][position.j+1] = machine;

                                // swaps the machines
                                machine.translateZ(-48);
                                machine2.translateZ(48);
                            }
                        }
                    } 
                    // A key
                    else {
                        if ((position.j-1) >= 0) {
                            // stores the machine
                            let machine = factoryDisposition[position.i][position.j];

                            // position is free
                            if (!factoryDisposition[position.i][position.j-1]) {
                                // stores the machine's new position
                                factoryDisposition[position.i][position.j-1] = machine;
                                // clears the machine's previous position
                                factoryDisposition[position.i][position.j] = 0;

                                // moves the machine to the left
                                machine.translateZ(48);
                            }
                            // position already has another machine
                            else {
                                // stores the second machine
                                let machine2 = factoryDisposition[position.i][position.j-1];

                                // swaps the machines' positions
                                factoryDisposition[position.i][position.j] = machine2;
                                factoryDisposition[position.i][position.j-1] = machine;

                                // swaps the machines
                                machine.translateZ(48);
                                machine2.translateZ(-48);
                            }
                        }
                    }
                }
            }

            /* return the position of the machine in the matrix */
            function findIndices(machineUUID) {
                let i;
                let j;

                for (i = 0; i < factoryDisposition.length; i++) {
                    for (j = 0; j < factoryDisposition[i].length; j++) {
                        if (factoryDisposition[i][j].uuid === selectedMachine) {
                            return {
                                i: i,
                                j: j
                            };
                        }
                    }
                }

                return;
            }
		</script>
	</body>
</html>
